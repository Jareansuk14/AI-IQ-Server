//AI-Server/server.js - ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö LIFF Share Target Picker
const express = require('express');
const cors = require('cors');
const path = require('path');
const fs = require('fs'); 
const { connectDB, checkConnection } = require('./config/db');
const paymentChecker = require('./services/paymentChecker'); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ
require('dotenv').config();

const app = express();

// ‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ raw body ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ middleware ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î
app.use(express.json({
  verify: (req, res, buf) => {
    req.rawBody = buf;
  },
  limit: '50mb' // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î
}));

app.use(express.urlencoded({ extended: false, limit: '50mb' }));

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ CORS ‡∏ó‡∏µ‡πà‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
app.use(cors({
  origin: ['http://localhost:3001', 'https://your-frontend-url.com', '*'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Line-Signature'],
  credentials: true
}));

// ‚úÖ ‡πÄ‡∏™‡∏¥‡∏£‡πå‡∏ü static files ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö LIFF Apps
app.use('/public', express.static(path.join(__dirname, 'public')));

// Serve static images for CALL/PUT signals (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AI-Auto)
app.use('/images', express.static(path.join(__dirname, 'assets')));

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° route ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö LIFF Share App
app.get('/liff-share', (req, res) => {
  const liffHtmlPath = path.join(__dirname, 'public', 'liff-share.html');
  
  if (fs.existsSync(liffHtmlPath)) {
    res.sendFile(liffHtmlPath);
  } else {
    res.status(404).json({
      error: 'LIFF app not found',
      message: 'Please create public/liff-share.html file'
    });
  }
});

// ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
app.use('/webhook', require('./routes/webhook'));
app.use('/api/admin', require('./routes/admin'));
app.use('/api/auth', require('./routes/auth'));
app.use('/api/payment', require('./routes/payment')); // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å /payment ‡πÄ‡∏õ‡πá‡∏ô /api/payment
app.use('/payment', require('./routes/payment')); // ‡πÄ‡∏û‡∏¥‡πà‡∏° route ‡πÄ‡∏Å‡πà‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠ backward compatibility

// ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
app.get('/', (req, res) => {
  res.send('LINE Bot server is running!');
});

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á LIFF config ‡πÑ‡∏õ‡∏¢‡∏±‡∏á frontend
app.get('/api/liff/config', (req, res) => {
  res.json({
    liffId: process.env.LIFF_ID || null
  });
});

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö LIFF configuration
app.get('/api/liff/status', (req, res) => {
  const liffHtmlPath = path.join(__dirname, 'public', 'liff-share.html');
  const liffExists = fs.existsSync(liffHtmlPath);
  
  res.json({
    liffApp: {
      path: liffHtmlPath,
      exists: liffExists,
      url: liffExists ? `${process.env.BASE_URL || 'http://localhost:3000'}/liff-share` : null
    },
    environment: {
      baseUrl: process.env.BASE_URL || 'http://localhost:3000',
      liffId: process.env.LIFF_ID || 'NOT_SET'
    },
    ready: liffExists && process.env.LIFF_ID
  });
});

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö Share Target Picker
app.get('/api/liff/test-share', (req, res) => {
  const { code } = req.query;
  
  if (!code) {
    return res.status(400).json({
      error: 'Missing referral code',
      usage: '/api/liff/test-share?code=ABC123'
    });
  }
  
  const testShareCard = {
    type: "flex",
    altText: `üéÅ ‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏ü‡∏£‡∏µ! ‡πÉ‡∏ä‡πâ‡∏£‡∏´‡∏±‡∏™ ${code}`,
    contents: {
      type: "bubble",
      header: {
        type: "box",
        layout: "vertical",
        contents: [
          {
            type: "text",
            text: "üéÅ ‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏ü‡∏£‡∏µ!",
            weight: "bold",
            color: "#ffffff",
            size: "lg",
            align: "center"
          }
        ],
        backgroundColor: "#722ed1",
        paddingAll: "20px"
      },
      body: {
        type: "box",
        layout: "vertical",
        contents: [
          {
            type: "text",
            text: `‡∏£‡∏´‡∏±‡∏™: ${code}`,
            weight: "bold",
            size: "xl",
            color: "#722ed1",
            align: "center"
          },
          {
            type: "text",
            text: `‡∏û‡∏¥‡∏°‡∏û‡πå ‡∏£‡∏´‡∏±‡∏™:${code}`,
            size: "sm",
            color: "#49aa19",
            align: "center",
            margin: "md"
          }
        ],
        paddingAll: "20px",
        backgroundColor: "#1f1f1f"
      },
      footer: {
        type: "box",
        layout: "vertical",
        contents: [
          {
            type: "button",
            style: "primary",
            action: {
              type: "uri",
              label: "üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
              uri: "https://line.me/R/ti/p/@033mebpp"
            },
            color: "#722ed1"
          }
        ],
        paddingAll: "20px",
        backgroundColor: "#1f1f1f"
      }
    }
  };
  
  res.json({
    message: 'Test share card generated',
    referralCode: code,
    shareCard: testShareCard,
    liffUrl: `${process.env.BASE_URL || 'http://localhost:3000'}/liff-share?code=${code}`
  });
});

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö
app.get('/api/status', (req, res) => {
  const dbConnected = checkConnection();
  res.json({
    server: 'running',
    database: dbConnected ? 'connected' : 'disconnected',
    environment: process.env.NODE_ENV || 'development',
    timestamp: new Date().toISOString()
  });
});

// ‡πÄ‡∏û‡∏¥‡πà‡∏° API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏ö‡∏ö manual (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö testing)
app.get('/api/payment/check', async (req, res) => {
  try {
    console.log('üîß Manual payment check requested');
    await paymentChecker.manualCheck();
    res.json({ message: 'Payment check completed', timestamp: new Date().toISOString() });
  } catch (error) {
    console.error('Manual payment check error:', error);
    res.status(500).json({ error: 'Payment check failed', details: error.message });
  }
});

// ‡πÄ‡∏û‡∏¥‡πà‡∏° API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
app.get('/api/payment/stats', async (req, res) => {
  try {
    const stats = await paymentChecker.getCheckStats();
    res.json(stats);
  } catch (error) {
    console.error('Payment stats error:', error);
    res.status(500).json({ error: 'Failed to get payment stats' });
  }
});

// ‡πÄ‡∏û‡∏¥‡πà‡∏° API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ pending payments
app.get('/api/payment/pending', async (req, res) => {
  try {
    const PaymentTransaction = require('./models/paymentTransaction');
    const pendingPayments = await PaymentTransaction.find({ status: 'pending' })
      .populate('user', 'lineUserId displayName')
      .sort({ createdAt: -1 });
    
    const formattedPayments = pendingPayments.map(p => ({
      id: p._id,
      lineUserId: p.lineUserId,
      amount: p.totalAmount,
      credits: p.credits,
      packageType: p.packageType,
      createdAt: p.createdAt,
      expiresAt: p.expiresAt,
      isExpired: p.isExpired(),
      timeLeft: Math.max(0, Math.floor((p.expiresAt - new Date()) / 60000)) // minutes left
    }));
    
    res.json({
      count: pendingPayments.length,
      payments: formattedPayments
    });
  } catch (error) {
    console.error('Error getting pending payments:', error);
    res.status(500).json({ error: 'Failed to get pending payments' });
  }
});

// ‡πÄ‡∏û‡∏¥‡πà‡∏° API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
app.get('/api/emails/recent', async (req, res) => {
  try {
    const { MongoClient } = require('mongodb');
    const client = new MongoClient(process.env.MONGODB_URI);
    await client.connect();
    const db = client.db();
    
    const recentEmails = await db.collection('emails')
      .find({})
      .sort({ receivedAt: -1 })
      .limit(10)
      .toArray();
    
    await client.close();
    
    const formattedEmails = recentEmails.map(email => ({
      id: email.id,
      subject: email.subject,
      from: email.from,
      receivedAt: email.receivedAt,
      processedBody: email.processedBody,
      transactionData: email.transactionData,
      paymentProcessed: email.paymentProcessed || false,
      paymentMatched: email.paymentMatched || false
    }));
    
    res.json({
      count: recentEmails.length,
      emails: formattedEmails
    });
  } catch (error) {
    console.error('Error getting recent emails:', error);
    res.status(500).json({ error: 'Failed to get recent emails' });
  }
});

// === ‡πÄ‡∏û‡∏¥‡πà‡∏° API endpoints ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AI-Auto ===

// API endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö AI-Auto
app.get('/api/test/forex', async (req, res) => {
  try {
    const { pair } = req.query;
    if (!pair) {
      return res.status(400).json({ error: 'Please provide pair parameter' });
    }
    
    const aiService = require('./services/aiService');
    const question = `‡πÉ‡∏ô‡∏Ñ‡∏π‡πà‡πÄ‡∏á‡∏¥‡∏ô ${pair} ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏Ñ‡∏ß‡∏£ CALL ‡∏´‡∏£‡∏∑‡∏≠ PUT ‡πÑ‡∏õ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏£‡∏≤‡∏ü‡∏à‡∏≤‡∏Å‡πÄ‡∏ß‡πá‡∏ö‡∏ï‡πà‡∏≤‡∏á‡πÜ‡πÉ‡∏´‡πâ‡∏´‡∏ô‡πà‡∏≠‡∏¢ ‡∏ï‡∏≠‡∏ö‡∏°‡∏≤‡∏™‡∏±‡πâ‡∏ô‡πÜ‡πÅ‡∏Ñ‡πà CALL ‡∏´‡∏£‡∏∑‡∏≠ PUT`;
    const result = await aiService.processForexQuestion(question);
    
    const { calculateNextTimeSlot } = require('./utils/flexMessages');
    const targetTime = calculateNextTimeSlot();
    
    res.json({
      pair: `${pair} (M5)`,
      prediction: result,
      targetTime,
      question,
      imageUrl: `${process.env.BASE_URL || 'http://localhost:3000'}/images/${result.toLowerCase()}-signal.jpg`
    });
  } catch (error) {
    console.error('Test forex API error:', error);
    res.status(500).json({ error: error.message });
  }
});

// API endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û
app.get('/api/images/check', (req, res) => {
  try {
    const assetsPath = path.join(__dirname, 'assets');
    const callImagePath = path.join(assetsPath, 'call-signal.jpg');
    const putImagePath = path.join(assetsPath, 'put-signal.jpg');
    
    const callExists = fs.existsSync(callImagePath);
    const putExists = fs.existsSync(putImagePath);
    
    res.json({
      assetsPath,
      images: {
        call: {
          path: callImagePath,
          exists: callExists,
          url: callExists ? `${process.env.BASE_URL || 'http://localhost:3000'}/images/call-signal.jpg` : null
        },
        put: {
          path: putImagePath,
          exists: putExists,
          url: putExists ? `${process.env.BASE_URL || 'http://localhost:3000'}/images/put-signal.jpg` : null
        }
      },
      ready: callExists && putExists
    });
  } catch (error) {
    console.error('Image check error:', error);
    res.status(500).json({ error: error.message });
  }
});

// API endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå assets (‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ)
app.get('/api/setup/assets', (req, res) => {
  try {
    const assetsPath = path.join(__dirname, 'assets');
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå assets ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ
    if (!fs.existsSync(assetsPath)) {
      fs.mkdirSync(assetsPath, { recursive: true });
      console.log('Created assets directory');
    }
    
    res.json({
      message: 'Assets directory ready',
      path: assetsPath,
      note: 'Please upload call-signal.jpg and put-signal.jpg to this directory'
    });
  } catch (error) {
    console.error('Setup assets error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå public (‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ)
app.get('/api/setup/liff', (req, res) => {
  try {
    const publicPath = path.join(__dirname, 'public');
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå public ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ
    if (!fs.existsSync(publicPath)) {
      fs.mkdirSync(publicPath, { recursive: true });
      console.log('Created public directory');
    }
    
    res.json({
      message: 'Public directory ready for LIFF apps',
      path: publicPath,
      note: 'Please create liff-share.html in this directory and set LIFF_ID in environment variables',
      nextSteps: [
        '1. Create LIFF app in LINE Developers Console',
        '2. Set LIFF_ID in .env file',
        '3. Create public/liff-share.html file',
        '4. Test with /api/liff/status'
      ]
    });
  } catch (error) {
    console.error('Setup LIFF error:', error);
    res.status(500).json({ error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏π‡πà‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
app.get('/api/forex/pairs', (req, res) => {
  try {
    const forexPairs = [
      // Major Pairs
      { pair: 'EUR/USD', category: 'Major', flag: 'üá™üá∫üá∫üá∏' },
      { pair: 'GBP/USD', category: 'Major', flag: 'üá¨üáßüá∫üá∏' },
      { pair: 'USD/JPY', category: 'Major', flag: 'üá∫üá∏üáØüáµ' },
      { pair: 'USD/CHF', category: 'Major', flag: 'üá∫üá∏üá®üá≠' },
      
      // Cross Pairs
      { pair: 'AUD/USD', category: 'Cross', flag: 'üá¶üá∫üá∫üá∏' },
      { pair: 'NZD/USD', category: 'Cross', flag: 'üá≥üáøüá∫üá∏' },
      { pair: 'USD/CAD', category: 'Cross', flag: 'üá∫üá∏üá®üá¶' },
      { pair: 'EUR/GBP', category: 'Cross', flag: 'üá™üá∫üá¨üáß' },
      
      // Special Assets
      { pair: 'EUR/JPY', category: 'Special', flag: 'üá™üá∫üáØüáµ' },
      { pair: 'GBP/JPY', category: 'Special', flag: 'üá¨üáßüáØüáµ' },
      { pair: 'BTC/USD', category: 'Crypto', flag: '‚Çø' },
      { pair: 'GOLD', category: 'Commodity', flag: 'ü•á' }
    ];
    
    res.json({
      totalPairs: forexPairs.length,
      pairs: forexPairs,
      categories: {
        Major: forexPairs.filter(p => p.category === 'Major').length,
        Cross: forexPairs.filter(p => p.category === 'Cross').length,
        Special: forexPairs.filter(p => p.category === 'Special').length,
        Crypto: forexPairs.filter(p => p.category === 'Crypto').length,
        Commodity: forexPairs.filter(p => p.category === 'Commodity').length
      }
    });
  } catch (error) {
    console.error('Error getting forex pairs:', error);
    res.status(500).json({ error: error.message });
  }
});

// === API endpoints ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Result Tracking System ===

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ú‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
app.get('/api/tracking/stats', (req, res) => {
  try {
    const resultTrackingService = require('./services/resultTrackingService');
    const stats = resultTrackingService.getTrackingStats();
    
    res.json({
      message: 'Tracking statistics',
      timestamp: new Date().toISOString(),
      ...stats
    });
  } catch (error) {
    console.error('Error getting tracking stats:', error);
    res.status(500).json({ error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö force stop ‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° (admin)
app.post('/api/tracking/force-stop/:userId', (req, res) => {
  try {
    const { userId } = req.params;
    const resultTrackingService = require('./services/resultTrackingService');
    
    resultTrackingService.forceStopTracking(userId);
    
    res.json({
      message: `Force stopped tracking for user ${userId}`,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error force stopping tracking:', error);
    res.status(500).json({ error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ IQ Option
app.get('/api/iq-option/test', async (req, res) => {
  try {
    const iqOptionService = require('./services/iqOptionService');
    const testResult = await iqOptionService.testConnection();
    
    res.json({
      message: 'IQ Option connection test',
      timestamp: new Date().toISOString(),
      ...testResult
    });
  } catch (error) {
    console.error('Error testing IQ Option connection:', error);
    res.status(500).json({ error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÅ‡∏ö‡∏ö manual
app.get('/api/iq-option/candle', async (req, res) => {
  try {
    const { pair, time, round } = req.query;
    
    if (!pair || !time || !round) {
      return res.status(400).json({ 
        error: 'Missing required parameters: pair, time, round' 
      });
    }
    
    const iqOptionService = require('./services/iqOptionService');
    const result = await iqOptionService.getCandleColor(pair, time, parseInt(round));
    
    res.json({
      message: 'Candle data retrieved',
      timestamp: new Date().toISOString(),
      request: { pair, time, round: parseInt(round) },
      ...result
    });
  } catch (error) {
    console.error('Error getting candle data:', error);
    res.status(500).json({ error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ IQ Option service
app.get('/api/iq-option/stats', (req, res) => {
  try {
    const iqOptionService = require('./services/iqOptionService');
    const stats = iqOptionService.getUsageStats();
    
    res.json({
      message: 'IQ Option service statistics',
      timestamp: new Date().toISOString(),
      ...stats
    });
  } catch (error) {
    console.error('Error getting IQ Option stats:', error);
    res.status(500).json({ error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≠‡∏ö (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö testing)
app.get('/api/iq-option/multiple-candles', async (req, res) => {
  try {
    const { pair, time, rounds } = req.query;
    
    if (!pair || !time || !rounds) {
      return res.status(400).json({ 
        error: 'Missing required parameters: pair, time, rounds' 
      });
    }
    
    const iqOptionService = require('./services/iqOptionService');
    const results = await iqOptionService.getMultipleCandles(pair, time, parseInt(rounds));
    
    res.json({
      message: 'Multiple candle data retrieved',
      timestamp: new Date().toISOString(),
      request: { pair, time, rounds: parseInt(rounds) },
      results
    });
  } catch (error) {
    console.error('Error getting multiple candle data:', error);
    res.status(500).json({ error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö admin ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î session ‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°
app.get('/api/admin/tracking/sessions', (req, res) => {
  try {
    // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ middleware ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå admin ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    const resultTrackingService = require('./services/resultTrackingService');
    const stats = resultTrackingService.getTrackingStats();
    
    res.json({
      message: 'Active tracking sessions',
      timestamp: new Date().toISOString(),
      totalSessions: stats.activeSessions,
      totalBlockedUsers: stats.blockedUsers,
      sessions: stats.sessions.map(session => ({
        ...session,
        duration: new Date() - session.startedAt,
        durationMinutes: Math.round((new Date() - session.startedAt) / 60000)
      }))
    });
  } catch (error) {
    console.error('Error getting tracking sessions:', error);
    res.status(500).json({ error: error.message });
  }
});

// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏£‡∏∞‡∏ö‡∏ö (comprehensive test)
app.get('/api/test/full-system', async (req, res) => {
  try {
    const results = {
      timestamp: new Date().toISOString(),
      tests: {}
    };
    
    // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Forex pairs
    results.tests.forexPairs = {
      totalPairs: 12,
      supportedPairs: [
        'EUR/USD', 'GBP/USD', 'USD/JPY', 'USD/CHF',
        'AUD/USD', 'NZD/USD', 'USD/CAD', 'EUR/GBP',
        'EUR/JPY', 'GBP/JPY', 'BTC/USD', 'GOLD'
      ]
    };
    
    // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö AI Service
    try {
      const aiService = require('./services/aiService');
      const testResponse = await aiService.processForexQuestion('Test question for EUR/USD CALL or PUT');
      results.tests.aiService = {
        status: 'working',
        response: testResponse
      };
    } catch (error) {
      results.tests.aiService = {
        status: 'error',
        error: error.message
      };
    }
    
    // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö IQ Option
    try {
      const iqOptionService = require('./services/iqOptionService');
      const iqTest = await iqOptionService.testConnection();
      results.tests.iqOption = iqTest;
    } catch (error) {
      results.tests.iqOption = {
        status: 'error',
        error: error.message
      };
    }
    
    // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Result Tracking
    const resultTrackingService = require('./services/resultTrackingService');
    const trackingStats = resultTrackingService.getTrackingStats();
    results.tests.resultTracking = {
      status: 'working',
      activeSessions: trackingStats.activeSessions,
      blockedUsers: trackingStats.blockedUsers
    };
    
    // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Images
    const callImageExists = fs.existsSync(path.join(__dirname, 'assets', 'call-signal.jpg'));
    const putImageExists = fs.existsSync(path.join(__dirname, 'assets', 'put-signal.jpg'));
    
    results.tests.images = {
      callSignal: callImageExists,
      putSignal: putImageExists,
      ready: callImageExists && putImageExists
    };
    
    // ‚úÖ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö LIFF
    const liffHtmlExists = fs.existsSync(path.join(__dirname, 'public', 'liff-share.html'));
    results.tests.liff = {
      htmlExists: liffHtmlExists,
      liffId: process.env.LIFF_ID ? 'SET' : 'NOT_SET',
      baseUrl: process.env.BASE_URL || 'http://localhost:3000',
      ready: liffHtmlExists && process.env.LIFF_ID
    };
    
    res.json(results);
  } catch (error) {
    console.error('Error running full system test:', error);
    res.status(500).json({ error: error.message });
  }
});

// Serve static assets for the admin dashboard
if (process.env.NODE_ENV === 'production') {
  const clientBuildPath = path.resolve(__dirname, 'client', 'build');
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå client/build ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  if (fs.existsSync(clientBuildPath)) {
    app.use(express.static(clientBuildPath));
    
    app.get('*', (req, res) => {
      // ‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API ‡πÅ‡∏•‡∏∞ webhook
      if (req.path.startsWith('/api/') || req.path.startsWith('/webhook') || req.path.startsWith('/payment') || req.path.startsWith('/images') || req.path.startsWith('/public') || req.path.startsWith('/liff-')) {
        return next();
      }
      res.sendFile(path.join(clientBuildPath, 'index.html'));
    });
  } else {
    console.log('Client build folder not found. Skipping static file serving.');
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° route ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö root path ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏î 404
    app.get('/', (req, res) => {
      res.json({ message: 'LINE Bot API is running!' });
    });
  }
} else {
  // ‡πÄ‡∏û‡∏¥‡πà‡∏° route ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö root path ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î development
  app.get('/', (req, res) => {
    res.json({ message: 'LINE Bot API is running in development mode!' });
  });
}

// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ error handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
app.use((err, req, res, next) => {
  console.error('Global error handler:', err);
  res.status(500).json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong'
  });
});

const PORT = process.env.PORT || 3000;

// ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
connectDB()
  .then(() => {
    console.log('Database connection attempt completed');
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á Rich Menu (‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Rich Menu)
    // ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏° server ‡πÉ‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å ‡πÉ‡∏´‡πâ‡πÉ‡∏™‡πà‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    if (process.env.CREATE_RICH_MENU === 'true') {
      require('./utils/createRichMenu');
    }
    
    // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
    setTimeout(() => {
      paymentChecker.startAutoCheck(2); // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å 2 ‡∏ô‡∏≤‡∏ó‡∏µ
      console.log('Payment checker started');
    }, 5000); // ‡∏£‡∏≠ 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°
  })
  .catch(err => {
    console.error('Database connection attempt failed:', err);
  })
  .finally(() => {
    // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
      console.log(`AI-Auto images served from: ${path.join(__dirname, 'assets')}`);
      console.log(`Image URLs: ${process.env.BASE_URL || `http://localhost:${PORT}`}/images/`);
      console.log(`LIFF Apps served from: ${path.join(__dirname, 'public')}`);
      console.log(`LIFF Share URL: ${process.env.BASE_URL || `http://localhost:${PORT}`}/liff-share`);
      console.log(`Result Tracking System: READY`);
      console.log(`IQ Option Integration: READY`);
      console.log(`Available API endpoints:`);
      console.log(`  - GET /api/test/full-system`);
      console.log(`  - GET /api/liff/status`);
      console.log(`  - GET /api/setup/liff`);
      console.log(`  - GET /liff-share?code=ABC123`);
    });
  });

// ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏∞‡∏≠‡∏≤‡∏î
process.on('SIGINT', async () => {
  console.log('Shutting down gracefully...');
  
  // ‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö payment checker
  await paymentChecker.stop();
  
  // ‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö result tracking (‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)
  try {
    const resultTrackingService = require('./services/resultTrackingService');
    // Force stop ‡∏ó‡∏∏‡∏Å session ‡∏ó‡∏µ‡πà active
    const stats = resultTrackingService.getTrackingStats();
    for (const session of stats.sessions) {
      if (session.isActive) {
        resultTrackingService.forceStopTracking(session.userId);
      }
    }
    console.log('All tracking sessions stopped');
  } catch (error) {
    console.error('Error stopping tracking sessions:', error);
  }
  
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('Shutting down gracefully...');
  
  // ‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö payment checker
  await paymentChecker.stop();
  
  // ‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö result tracking
  try {
    const resultTrackingService = require('./services/resultTrackingService');
    const stats = resultTrackingService.getTrackingStats();
    for (const session of stats.sessions) {
      if (session.isActive) {
        resultTrackingService.forceStopTracking(session.userId);
      }
    }
    console.log('All tracking sessions stopped');
  } catch (error) {
    console.error('Error stopping tracking sessions:', error);
  }
  
  process.exit(0);
});

